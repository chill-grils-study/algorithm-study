// dp 골드를 제 힘으로 풀다니...뿌듯하네요...
// 문제를 보고서 음~ 현재 숫자를 앞의 숫자랑 합치는 경우와 합치지 않는 경우로 분리해야겠다는 생각을 했어요.
// 그래서 이차원 배열을 사용했습니다.
// dp[i][0]: 앞의 숫자와 합치지 않고 만들 수 있는 배열의 개수
// dp[i][1]: 앞의 숫자와 합쳐서 만들 수 있는 배열의 개수
function solution(numbers) {
  const N = numbers.length;
  const dp = Array.from({ length: N }, () => Array(2).fill(0));
  // 첫번쨰 숫자는 이전 숫자와 합칠 수 없음
  dp[0][0] = 1;
  dp[0][1] = 0;

  for (let i = 1; i < N; i++) {
    const curNum = +numbers[i];
    const newNum = +`${numbers[i - 1]}${numbers[i]}`;
    // 숫자카드는 34까지 있으므로 합친 숫자가 34보다 작아야 붙일 수 있음
    if (newNum <= 34) {
      // 숫자를 3개 연속 붙일 수는 없으니 앞의 숫자의 합치지 않은 배열의 개수를 가져옴
      // 이전 배열에 숫자를 하나 더 붙이는 것 뿐이니 개수는 같음
      dp[i][1] = dp[i - 1][0];
    } // 현재 숫자가 0이 아닐 때만 값 갱신, 카드가 1부터 있으므로 0은 단독으로 존재할 수 없음
    if (curNum !== 0) {
      // 앞의 모든 경우의 수를 더해도 됨
      // 지금 숫자 하나만 붙일거니까 제약이 없음
      dp[i][0] = dp[i - 1][0] + dp[i - 1][1];
    }
  }

  console.log(dp[N - 1][0] + dp[N - 1][1]);
}
